---
layout: post
title: Adventures in Python optimisation
---

<p>A hobby of mine is converting Gutenberg transcriptions into nice ebooks for the <a href="https://standardebooks.org/">Standard Ebooks</a> project. Most recently I’ve been working on <a href="https://en.wikipedia.org/wiki/Samuel_Pepys">Pepys’s Diary</a> which, in the edition I’m working with, is stuffed full of footnotes.</p>
<p>Because footnotes aren’t very meaningful in a format where pages shift, the default approach is to convert them to endnotes. That worked fine for the initial build, but plenty were missing from the Gutenberg transcription I’m using, which means that I’m having to go back in and insert new endnotes, causing all the following ones to be renumbered. Luckily for me, Standard Ebooks’ tooling includes the <a href="https://github.com/standardebooks/tools/blob/master/reorder-endnotes">reorder-endnotes</a> script, but it’s pretty slow. Running it against the current state of the Diary (~1600 endnotes) to increment every endnote by one takes on average 100+ seconds. That’s pretty painful, and was seriously making me consider upgrading my laptop. But first I wanted to see if there was any software optimisations I could make.</p>

{{ excerpt_separator }}

<p>Standard Ebook’s tooling is written in Python 3, a language I’m not that familiar with. Having said that, most optimisations are logic based rather than language specific, so the first thing I did was check the hot loops. The first part of the script only works on <code>endnotes.xhtml</code>, so I skipped that as there were unlikely to be major speed optimisations for code that works on a single file. Looking at the second part of the code though I saw <a href="https://github.com/standardebooks/tools/blob/d3898ba9cac340c94adc8703a883d4cbc795e8f7/reorder-endnotes#L80-L81">two uses of <code>replace</code></a>, and had a sneaking suspicion. Sure enough, looking at the <a href="https://docs.python.org/3/library/stdtypes.html?highlight=replace#str.replace">replace documentation</a> there’s a <code>count</code> argument. We know that there’ll only be one instance of each endnote link in a file, so we can set that to 1 and retime the function. Unfortunately that only shaved a second and a half off the run. Nothing to sniff at but I wanted more. Still, <a href="https://github.com/standardebooks/tools/commit/afb92f74933c2c67effae0b0c986d7fe263a3c30#diff-9079fde95df6a29b1d2572a01cc2920d">worth committing.</a></p>

<p>Next up, could we do anything about the loop? There were actually <a href="https://github.com/standardebooks/tools/blob/afb92f74933c2c67effae0b0c986d7fe263a3c30/reorder-endnotes#L69-L78">two loops in play</a>, one looping over all the source files, and then looping inside the file for the endnotes. As we’re opening each file individually and running the same inner loop, this looked like a potential case for parallelisation. Now I’m no parallel computing expert, but WebWorkers aren’t exactly difficult so I had a look around in the Python docs for something similar, and hit on <a href="https://docs.python.org/3/library/concurrent.futures.html">concurrent futures</a>. The given examples made it look reasonably simple: import the library, create a <code>ProcessPoolExecutor</code>, then submit your function to the executor as the first thing inside your loop. Easy to test and easy to use, as <a href="https://github.com/standardebooks/tools/commit/1f80544c6fe45ab3e444c223b114c0bf3a4969bf">it turned out to nearly double the speed of the script</a> on my dual-core machine.</p>

<p>Finally, what about the replacement loop? I realised that it’d loop over every possible endnote in the file search to see what it could replace. It needs to do that to start with, but endnotes are in order within a file (and book). If it’s started replacing them already then can’t find one it by necessity won’t find any more in that file and we can break the loop. To my surprise, <a href="https://github.com/standardebooks/tools/pull/116/commits/4bed0e65400e680f536ef600b3a87958e3d705f1">adding a dirty flag and loop breaking</a> halved the time again. A 75% reduction in function time is nothing to be sniffed at, and I opened a PR to get that into the project.</p>

<p>Now that those were merged into master I carried on working on Pepys. A massive improvement in speed obviously, but as more and more endnotes were added the script started slowing down again. What had been 16s to run was now up to 22s; still an improvement, but it left me wondering if there were any more improvements I could do. Time to dive in the code again.</p>

<p>Looking back at the replacement loop again, I tried disabling each of the three lines. Turning off the two replacement lines lead to a small improvement in speed, but disabling the <a href="https://github.com/standardebooks/tools/blob/dc136593e9ce2ecfd8a13b4de7a622dbc0e62038/reorder-endnotes#L88">line with the regular expression</a> dropped the processing time from 22s to 5s! Can we do anything about that code? I was wondering about caching of regular expressions, but it looks like Python does that automatically. The problem though is that it still needs to build a matching regex and a replacement regex for each endnote: at this point over 3000 of them. It turns out that there’s a count flag for regex substitution as well, but this didn’t help much. Was is possible to simplify the regex a bit? Negative sets are pretty painful from a performance point of view, and we were just looking for an <code>a</code> element with attributes. Replacing the negative search for a <code>&gt;</code> with a positive search for a space (<code>\s</code>) knocked a second off, but I wanted more. In the end I managed to <a href="https://github.com/robinwhittleton/tools/blob/further-endnote-changes/reorder-endnotes#L100">replace the regular expression completely with a normal string replacement</a>, and sure enough the performance matches those of the other string replacements: the overall function with ~1600 endnotes now takes around 5s.</p>

<p>Overall I’m super happy with a twenty-times increase in speed. It’ll save me many hours of CPU time over the course of finishing Pepys’s Diary, and have given me a better insight into Python performance. It’s probably worth pointing out that I’m the outlier here: the usual process of making it work, making it correct and making it fast had stopped at correct purely because for most books (with maybe 10-20 endnotes) it was fast enough already. I’m just trying to build a book with many thousands of endnotes on a six year old ultrabook, and if I’m able to extract another year or two out of it I’m more than happy to do a couple of hours of software optimisation.</p>
